import React, { useEffect, useRef } from 'react';

interface ModelViewerProps {
  src: string;
  wireframeEnabled?: boolean;
  materialEnabled?: boolean;
  textureEnabled?: boolean;
}

const ModelViewer: React.FC<ModelViewerProps> = ({ 
  src, 
  wireframeEnabled = false,
  materialEnabled = true,
  textureEnabled = true 
}) => {
  const viewerRef = useRef<HTMLDivElement>(null);
  const modelViewerRef = useRef<any>(null);

  // Initialize model-viewer once
  useEffect(() => {
    let isMounted = true;

    const initializeViewer = async () => {
      try {
        await import('@google/model-viewer');
        
        if (!isMounted || !viewerRef.current || modelViewerRef.current) return;

        const modelViewer = document.createElement('model-viewer');
        modelViewerRef.current = modelViewer;
        
        // Set basic attributes once
        modelViewer.setAttribute('alt', '3D model');
        modelViewer.setAttribute('camera-controls', '');
        modelViewer.setAttribute('auto-rotate', '');
        modelViewer.setAttribute('min-field-of-view', '10deg');
        modelViewer.setAttribute('max-field-of-view', '120deg');
        
        // Styling
        modelViewer.style.width = '100%';
        modelViewer.style.height = '100%';
        modelViewer.style.background = 'transparent';
        
        // Event listeners
        modelViewer.addEventListener('load', () => {
          console.log('Model loaded successfully');
        });

        modelViewer.addEventListener('error', (event) => {
          console.error('Error loading model:', event);
        });
        
        viewerRef.current.appendChild(modelViewer);
      } catch (error) {
        console.error('Error importing model-viewer:', error);
      }
    };

    initializeViewer();

    return () => {
      isMounted = false;
      if (modelViewerRef.current && viewerRef.current) {
        try {
          viewerRef.current.removeChild(modelViewerRef.current);
        } catch (e) {
          // Child might already be removed
        }
        modelViewerRef.current = null;
      }
    };
  }, []);

  // Update src when it changes
  useEffect(() => {
    if (modelViewerRef.current && src) {
      modelViewerRef.current.setAttribute('src', src);
    }
  }, [src]);

  // Update display options without recreating the element
  useEffect(() => {
    if (modelViewerRef.current) {
      // Apply wireframe effect
      if (wireframeEnabled) {
        modelViewerRef.current.style.filter = 'contrast(200%) brightness(150%) invert(0.1)';
      } else {
        modelViewerRef.current.style.filter = 'none';
      }
      
      // Material and texture controls would go here when we add more advanced features
      // For now, materialEnabled and textureEnabled are placeholders
    }
  }, [wireframeEnabled, materialEnabled, textureEnabled]);

  return (
    <div 
      ref={viewerRef}
      style={{ 
        width: '100%',
        height: '100%',
        minWidth: '300px',
        minHeight: '400px',
        maxWidth: '1400px',
        maxHeight: 'calc(100vh - 180px)',
        background: '#1a1a1a', 
        borderRadius: '8px', 
        overflow: 'hidden',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        color: '#fff'
      }}
    >
      Loading 3D Model...
    </div>
  );
};

export default ModelViewer;